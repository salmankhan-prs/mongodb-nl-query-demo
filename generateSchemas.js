// MongoDB Schema Generator for Natural Language Query Demo
// Similar to ai-interview-be generateSchemas.js but adapted for e-commerce demo
require("dotenv/config");
const fs = require("fs").promises;
const path = require("path");

const { getAllCollectionSchemas, extractAllRelationships } = require("./dist/services/schemaGenerator");

/**
 * Generate the TypeScript file with COMPLETE schemas
 */
async function writeCompleteSchemaFile(formattedSchemas, relationships) {
  const outputPath = path.join(__dirname, "./src/utils/generatedSchemas.ts");

  const content = `// Auto-generated MongoDB collection schemas from Mongoose models
// Generated at: ${new Date().toISOString()}
// Total collections: ${Object.keys(formattedSchemas).length}
// Generation mode: COMPLETE - All fields, enums, and relationships preserved
// Source: Dynamic introspection of Mongoose models
// 
// ‚ö†Ô∏è  DO NOT EDIT MANUALLY - This file is automatically generated
// To regenerate: Run 'pnpm generate:schemas'

import { ECollectionNames } from '../types';

/**
 * Schema Format Guide (from ai-interview-be approach):
 * - (required) = Field is required
 * - (unique) = Field must be unique
 * - (indexed) = Field is indexed for performance
 * - -> CollectionName = Reference to another collection
 * - [value1|value2|...] = ALL possible enum values
 * - {min:X,max:Y} = Numeric or length constraints
 * - Array<Type> = Array of specified type
 * - Object<{...}> = Nested object with all properties listed
 */

// üéØ AGENT-Optimized Collection Schemas with COMPLETE information
export const JSON_SCHEMA: Record<ECollectionNames, Record<string, string>> = ${JSON.stringify(formattedSchemas, null, 2)};

// üîó Complete Collection Relationships
export const COLLECTION_RELATIONSHIPS: Partial<Record<ECollectionNames, Array<{
  field: string;
  targetCollection: any;
  targetModel: string;
  type: 'reference' | 'array-reference' | 'nested-reference';
  required: boolean;
}>>> = ${JSON.stringify(relationships, null, 2)};

// üìà Schema Metadata
export const SCHEMA_METADATA = {
  generatedAt: '${new Date().toISOString()}',
  totalCollections: ${Object.keys(formattedSchemas).length},
  totalFields: ${Object.values(formattedSchemas).reduce((acc, s) => acc + Object.keys(s).length, 0)},
  totalRelationships: ${Object.values(relationships).reduce((acc, rels) => acc + rels.length, 0)},
  generatedFrom: 'Mongoose Models (E-commerce Demo)',
  format: 'COMPLETE - No truncation',
  sourceEnum: 'ECollectionNames',
  completeness: {
    enumValues: 'ALL values included',
    nestedObjects: 'ALL properties included', 
    relationships: 'ALL references mapped',
    constraints: 'ALL validations included'
  }
};

// Helper types for RE+ACT Agent
export type CollectionSchema = typeof JSON_SCHEMA;
export type CollectionName = keyof CollectionSchema;
export type SchemaRelationships = typeof COLLECTION_RELATIONSHIPS;

// Verify all enum values have schemas
const _schemaCompleteness: Record<ECollectionNames, any> = JSON_SCHEMA;
`;

  await fs.writeFile(outputPath, content, "utf-8");
  console.log(`‚úÖ Complete schema file written to: ${outputPath}`);
}

async function generateSchemas() {
  try {
    console.log("üöÄ Starting COMPLETE schema generation from Mongoose models...");
    console.log("üìã Using dynamic model introspection (ai-interview-be approach)\n");

    console.log("üîç Extracting ALL schema information...");
    const formattedSchemas = getAllCollectionSchemas();

    console.log("üîç Extracting ALL collection relationships...");
    const relationships = extractAllRelationships();

    console.log("üíæ Writing COMPLETE schema file...");
    await writeCompleteSchemaFile(formattedSchemas, relationships);

    // Print detailed summary
    console.log("\n" + "=".repeat(50));
    console.log("üìä COMPLETE GENERATION SUMMARY");
    console.log("=".repeat(50));
    console.log(`Collections Processed: ${Object.keys(formattedSchemas).length}`);
    console.log(`Total Fields: ${Object.values(formattedSchemas).reduce((acc, s) => acc + Object.keys(s).length, 0)}`);
    console.log(
      `Total Relationships Found: ${Object.values(relationships).reduce((acc, rels) => acc + rels.length, 0)}`,
    );

    // Show relationship details
    console.log("\nüìé Relationships by Collection:");
    for (const [collection, rels] of Object.entries(relationships)) {
      console.log(`  ${collection}: ${rels.length} relationships`);
      for (const rel of rels.slice(0, 3)) {
        // Show first 3 as examples
        console.log(`    - ${rel.field} -> ${rel.targetCollection} (${rel.type})`);
      }
      if (rels.length > 3) {
        console.log(`    ... and ${rels.length - 3} more`);
      }
    }

    console.log("=".repeat(50));
    console.log("\n‚úÖ COMPLETE schema generation finished successfully!");
    console.log("üìù All enum values, nested fields, and relationships preserved.");
  } catch (error) {
    console.error("‚ùå Schema generation failed:", error);
    process.exit(1);
  }
}

if (require.main === module) {
  generateSchemas();
}
